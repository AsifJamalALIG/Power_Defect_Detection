import os
from torch.utils.data import Dataset, DataLoader
from PIL import Image
import torchvision.transforms as transforms
import torch
import matplotlib.pyplot as plt

# Define the custom dataset class
class PoleDataset(Dataset):
    def __init__(self, images_dir, labels_dir, transform=None):
        self.images_dir = images_dir
        self.labels_dir = labels_dir
        self.transform = transform
        self.images = sorted(os.listdir(images_dir))
        self.labels = sorted(os.listdir(labels_dir))
        
    def __len__(self):
        return len(self.images)
    
    def __getitem__(self, idx):
        img_path = os.path.join(self.images_dir, self.images[idx])
        label_path = os.path.join(self.labels_dir, self.labels[idx])

        # Load image
        image = Image.open(img_path).convert('RGB')

        # Load label (assumed to be in YOLO txt format)
        with open(label_path, 'r') as f:
            label = f.readlines()

        # Apply transformations if any
        if self.transform:
            image = self.transform(image)

        # Convert labels to tensor (dummy for now, adjust based on your txt structure)
        label_tensor = torch.tensor([float(x) for x in label[0].split()])

        return image, label_tensor, img_path  # Return the img_path for display

# Paths to dataset folders
train_images_dir = "/kaggle/input/pole-defects-1/Pole_Detection.v2i.yolov5pytorch/train/images"
train_labels_dir = "/kaggle/input/pole-defects-1/Pole_Detection.v2i.yolov5pytorch/train/labels"

# Image transformations (resize, normalize, etc.)
transform = transforms.Compose([
    transforms.Resize((256, 256)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Create datasets
train_dataset = PoleDataset(train_images_dir, train_labels_dir, transform=transform)

# Use smaller batch size to reduce memory load
train_loader = DataLoader(train_dataset, batch_size=1, shuffle=True)

# Iterate through the dataset and output "Yes" or "No" based on defect presence
for i, (image, labels, img_path) in enumerate(train_loader):
    # Get the class label (first element in the label tensor)
    class_label = labels[0][0].item()
    
    # Determine if it's defected or not based on the class label
    defect_status = "No" if class_label == 1 else "Yes"
    
    # Convert the image tensor to a NumPy array for displaying
    image_np = image.squeeze().permute(1, 2, 0).numpy()  # Change shape from (C, H, W) to (H, W, C)

    # De-normalize the image
    image_np = (image_np * np.array([0.229, 0.224, 0.225]) + np.array([0.485, 0.456, 0.406])).clip(0, 1)
    
    # Display the image with defect status
    plt.imshow(image_np)
    plt.title(f"Defected? {defect_status}")
    plt.axis('off')  # Hide axes
    plt.show()  # Display the image
    
    # Output the result in the console as well
    print(f"Image {i + 1}: Defected? {defect_status}")
